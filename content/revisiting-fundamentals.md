Title: Revisiting CS/Software fundamentals/foundations: My learning plan
Date: 2025-11-30 22:03
Tags: ossu,computer-science

Lately, I’ve been thinking about the importance of foundations. The foundations that make you not just a competent programmer, but a truly great one. The kind of engineer who understands systems deeply, reasons clearly about problems, and writes code that reflects strong design principles.

Because of how essential foundational knowledge is, I’ve decided that over the next couple of years, I’ll be revisiting the fundamentals of computer science, software engineering, and programming. Not because I’ve completely forgotten them, but because I want to master them at a deeper level. Also, there are many solid resources out there that I want to take advantage of, and topics that I didn't get to cover during my undergrad.

### Why go back to the basics?

First, a little background. I earned a Bachelor’s degree in Computer Science & Engineering back in 2019. It took me four years. Between 2019 until now, I got 3.5 years of professional software engineering experience. I also had some career gaps in between due to personal reasons.

I feel like I did a solid job at learning the fundamentals during my undergrad. I was motivated, learned how to learn, practiced deep work, and I had good exposure to math, algorithms, data structures, basics of programming, computer organization/architecture, networks, OS, etc.  You can find my relevant course work on my [LinkedIn](https://www.linkedin.com/in/miguel-hernandez-535b05102/) in the Education section.

But as time has passed, I’ve realized there are areas I never got to touch (such as other programming languages, compilers, cybersecurity, software architecture, etc). These are areas that I feel like if I learn them, I would be a stronger engineer.

This isn’t about repeating old material. It’s about going deeper. I want to refine my understanding, close knowledge gaps, and revisit concepts with more maturity and context than I had back in school.

### What about a Master's degree?

At one point, I considered pursuing a master’s degree. People sometimes ask me, “Why not just go for a master’s?” The more I thought about it and researched, the more I realized that mastering the fundamentals instead would be a better investment for me in the long run, especially since my goal is to work in industry in a non-research-related role as a software engineer.

Some might argue that you need strong foundations to complete one in the first place, and there’s definitely some truth to that. By all means, if you are strong in your fundamentals and want to pursue a master's in a topic of interest, then go ahead. I'm not against a master's, it's just not the right fit for my situation.

A master’s in Computer Science can be an indicator of expertise. After all, “master” is in the title. But I’ve come to believe that it’s more valuable mainly if you’re pursuing research-heavy roles, targeting a specific area in industry, or planning to stay in academia, which does not apply to me.

I think of getting a master's like adding branches to a tree of knowledge. And I think of getting a bachelor's as strengthening the trunk of said tree. I already have a bachelor's, but going through another one will make my knowledge tree trunk even stronger, which is more important to me right now.

### My Learning Roadmap

The goal is to complete the necessary courses from Open Source Society University [Computer Science curriculum](https://github.com/ossu/computer-science). It has online courses from top universities such as MIT, Stanford, etc.

I started about a month ago, taking the courses [Systematic Program Design](https://github.com/ossu/computer-science/blob/master/coursepages/spd/README.md) and [Mathematics for Computer Science](https://openlearninglibrary.mit.edu/courses/course-v1:OCW+6.042J+2T2019/about).

Systematic Program Design focuses on how to think systematically about programming.  The language used is Racket, which is a dialect of Lisp and descendant of Scheme. In this course, we learn the basics of Racket (data types, built-in functions, libraries, images, functions, etc). Then, we learn particular code structures/patterns. One of the final projects is to build the game Space Invaders, which should be fun. Racket is a good pedagogical language to learn core principles that can be applied to any programming language.

Math for Computer Science is basically discrete math. The topics covered are proofs, structures, counting, and probability. I'm taking this to keep my brain sharp.  The instructor states that one of the most important skills we can have in life is being able to tell the difference between a logical argument that appears to be sound, but is actually bogus, and a logical argument that is actually sound.

After SPD, I will take the next course in its section, which is Class-based Program Design. After Math for CS, I will probably take the course [Build a Modern Computer from First Principles: From Nand to Tetris](https://www.coursera.org/learn/build-a-computer), and continue in that section.

I'll keep going down the list for Core Programming section, while concurrently going through another course from another section.  Doing just 2 courses concurrently for now but that may change.

### The Bigger Picture

This isn’t just about landing a job or checking boxes on a résumé. I’m taking a long-term view.

I don’t just want a job. I want a thriving career as a software engineer. That means investing in the skills that will still matter decades from now: fundamentals, reasoning, design, and adaptability.

By revisiting the core ideas behind programming and computer science, I’m building a foundation that will support everything else I learn moving forward. Strong fundamentals make you adaptable. They allow you to see patterns others miss and approach problems from first principles.

### Looking Ahead

I'm genuinely excited to learn. I’ll be documenting this entire journey through blog posts, notes, and reflections. I want this blog to serve as both a record of my growth and a resource for others walking a similar path.
